package lifya.parsergenerator.language;

import java.io.IOException;

import lifya.Source;
import lifya.Token;
import lifya.generic.lexeme.Lexeme;
import lifya.parsergenerator.GeneratorConstants;
import lifya.parsergenerator.ParserGenerator;
import speco.array.Array;

/**
 * A Lexeme (token type recognizer) generated by the Lifya parser generator
 */
public class GeneratorLexeme extends Lexeme{
	protected String type;
	protected Token tree;
	
	/**
	 * Creates a token type recognizer (not embedded in a Lifya parser)
	 * @param type Token type
	 * @param code Lifya token type recognizer specification
	 * @throws IOException If not valid Lifya token type recognizer specification
	 */	
	public GeneratorLexeme( String type, String code ) throws IOException{
		this( type, code, false);
	}
	
	/**
	 * Creates a token type recognizer
	 * @param type Token type
	 * @param code Lifya token type recognizer specification
	 * @param embedded If the token type recognizer is embedded in a Lifya parser or not
	 * @throws IOException If not valid Lifya token type recognizer specification
	 */	
	public GeneratorLexeme( String type, String code, boolean embedded ) throws IOException{
		this( type, (new GeneratorParser(false, embedded)).get(new Source("generator-lexeme",code)));
	}
	
	/**
	 * Creates a token type recognizer
	 * @param type Token type
	 * @param tree Derivation tree for the Lifya token type recognizer
	 * @throws IOException If not valid Lifya token type recognizer specification
	 */	
	public GeneratorLexeme( String type, Token tree ) throws IOException{
		super(type);
		this.tree = tree; 
	}	
	
	protected int[] match_exp(Source input, Token t) {
		int pos=input.pos();
		@SuppressWarnings("unchecked")
		Array<Token> a = (Array<Token>)t.value();
		int[] final_consumed = null;
		for( int i=0; i<a.size(); i++ ) {
			int[] consumed = match(input, a.get(i));
			input.locate(pos);
			if(final_consumed==null || (final_consumed[0]==0 && consumed[0]==1) ||
				(final_consumed[0]==consumed[0] && final_consumed[1]<consumed[1])) final_consumed = consumed;
		}
		if(final_consumed[0]==1) input.locate(pos+final_consumed[1]);
		return final_consumed;
	}

	protected int[] match_join(Source input, Token t) {
		int pos=input.pos();
		@SuppressWarnings("unchecked")
		Array<Token> a = (Array<Token>)t.value();
		int[] total_consumed = new int[] {1,0};
		for( int i=0; i<a.size(); i++ ) {
			int[] consumed = match(input, a.get(i));
			if(consumed[0]==0) {
				input.locate(pos);
				consumed[1] = total_consumed[1];
				return consumed;
			}
			total_consumed[1] += consumed[1];
		}
		return total_consumed;
	}

	protected int[] match_term(Source input, Token t) {
		int start=input.pos();
		@SuppressWarnings("unchecked")
		Array<Token> a = (Array<Token>)t.value();
		int[] consumed = match(input, a.get(0));
		char closure = ((String)a.get(1).value()).charAt(0);
		switch(closure) {
			case '?':
				consumed[0]=1;
				return consumed;
			case '+':
				if(consumed[0]==0) return consumed;					
			break;
			case '*':
				if(consumed[0]==0) {
					consumed[0]=1;
					return consumed;										
				}
		}
		
		while(consumed[0]==1) consumed = match(input, a.get(0));
		consumed[0] = 1;
		consumed[1] = input.pos()-start;
			
		return consumed;
	}
	
	protected boolean match_category(char CAT, char c) {
		switch(CAT) {
			case 'l': return ('a'<=c && c<='z') || ('A'<=c && c<='Z');
			case 'L': return !(('a'<=c && c<='z') || ('A'<=c && c<='Z'));
			case 'd': return Character.isDigit(c);
			case 'D': return !Character.isDigit(c);
			case 'w': return Character.isAlphabetic(c);
			case 'W': return !Character.isAlphabetic(c);
			case 'S': return (c!=' ');
			default: return false;
		}			
	}
	
	protected int[] match_category(Source input, Token t) {
		int pos = input.pos();
		String value = (String)t.value();
		char c = input.current();
		switch(value.charAt(0)) {
			case '.':
				input.next();
				return new int[] {1,1};
			case '\\':
				if(match_category(value.charAt(1),c)) {
					input.next();
					return new int[] {1,1};
				}else {
					input.locate(pos);
					return new int[] {0,0};
				}	
			default:	
				return new int[] {0,0};
		}
	}
		
	protected int[] match_any(Source input, Token t) {
		int pos = input.pos();
		String value = ParserGenerator.escape_all((String)t.value());
		char c = input.current();
		for( int k=0; k<value.length(); k++) {
			if(c!=value.charAt(k)) {
				input.locate(pos);
				return new int[] {0,k};
			}
			c = input.next();
		}	
		return new int[] {1,value.length()};
	}
	
	protected int[] match_range(Source input, Token t) {
		@SuppressWarnings("unchecked")
		Array<Token> a = (Array<Token>)t.value();
		char start = ParserGenerator.escape((String)a.get(0).value());
		char end = ParserGenerator.escape((String)a.get(1).value());
		char c = input.current();
		if(start<=c && c<=end) {
			input.next();
			return new int[] {1,1};		
		}else return new int[] {0,0};
	}	

	protected int[] match_not(Source input, Token t) {
		if(input.eoi()) return new int[] {0,0};
		int pos = input.pos();
		t = (Token)t.value();
		int[] current = match(input,t);
		if(current[0]==1) {
			current[1] = 0; 
			input.locate(pos);
		}else {
			current[1] = 1;
			input.next();
		}
		current[0] = 1-current[0];
		return current;
	}	
	
	protected int[] match(Source input, Token t) {
		switch(t.type()) {
			case GeneratorConstants.EXP: return match_exp(input, t);
			case GeneratorConstants.ANY: return match_any(input, t);
			case GeneratorConstants.CATEGORY: return match_category(input, t);
			case GeneratorConstants.RANGE: return match_range(input, t);
			case GeneratorConstants.TERM: return match_term(input,t);
			case GeneratorConstants.JOIN: return match_join(input,t);
			case GeneratorConstants.NOT: return match_not(input,t);
		}
		return new int[] {0,0};
	}

	/**
	 * Reads a token from the input source 
	 * @param input Symbol source
	 * @return Token read from the symbol source
	 */
	@Override
	public Token match(Source input) {
		int pos = input.pos();
		int[] consumed = match(input,tree);
		if(consumed[0]==0) return error(input,pos);
		return token(input,pos,input.substring(pos, input.pos()));
	}


	/**
	 * Determines if the token type can star with the given character
	 * @param c Character to analyze
	 * @return <i>true</i> If the token type can start with the given character <i>false</i> otherwise
	 */
	@Override
	public boolean startsWith(char c) {
		int[] consumed = match(new Source("inner-lexeme",""+c),tree);
		return consumed[1]>=1; 
	}
}